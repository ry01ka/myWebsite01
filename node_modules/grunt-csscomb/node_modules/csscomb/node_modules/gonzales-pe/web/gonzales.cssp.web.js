var cssToAST = (function() {
var TokenType = {
    StringSQ: 'StringSQ',
    StringDQ: 'StringDQ',
    CommentML: 'CommentML',
    CommentSL: 'CommentSL',
    Newline: 'Newline',
    Space: 'Space',
    Tab: 'Tab',
    ExclamationMark: 'ExclamationMark',
    QuotationMark: 'QuotationMark',
    NumberSign: 'NumberSign',
    DollarSign: 'DollarSign',
    PercentSign: 'PercentSign',
    Ampersand: 'Ampersand',
    Apostrophe: 'Apostrophe',
    LeftParenthesis: 'LeftParenthesis',
    RightParenthesis: 'RightParenthesis',
    Asterisk: 'Asterisk',
    PlusSign: 'PlusSign',
    Comma: 'Comma',
    HyphenMinus: 'HyphenMinus',
    FullStop: 'FullStop',
    Solidus: 'Solidus',
    Colon: 'Colon',
    Semicolon: 'Semicolon',
    LessThanSign: 'LessThanSign',
    EqualsSign: 'EqualsSign',
    GreaterThanSign: 'GreaterThanSign',
    QuestionMark: 'QuestionMark',
    CommercialAt: 'CommercialAt',
    LeftSquareBracket: 'LeftSquareBracket',
    ReverseSolidus: 'ReverseSolidus',
    RightSquareBracket: 'RightSquareBracket',
    CircumflexAccent: 'CircumflexAccent',
    LowLine: 'LowLine',
    LeftCurlyBracket: 'LeftCurlyBracket',
    VerticalLine: 'VerticalLine',
    RightCurlyBracket: 'RightCurlyBracket',
    Tilde: 'Tilde',
    Identifier: 'Identifier',
    DecimalNumber: 'DecimalNumber'
};
var getTokens = (function() {
    var Punctuation,
        urlMode = false,
        blockMode = 0;
    Punctuation = {
        ' ': TokenType.Space,
        '\n': TokenType.Newline,
        '\r': TokenType.Newline,
        '\t': TokenType.Tab,
        '!': TokenType.ExclamationMark,
        '"': TokenType.QuotationMark,
        '#': TokenType.NumberSign,
        '$': TokenType.DollarSign,
        '%': TokenType.PercentSign,
        '&': TokenType.Ampersand,
        '\'': TokenType.Apostrophe,
        '(': TokenType.LeftParenthesis,
        ')': TokenType.RightParenthesis,
        '*': TokenType.Asterisk,
        '+': TokenType.PlusSign,
        ',': TokenType.Comma,
        '-': TokenType.HyphenMinus,
        '.': TokenType.FullStop,
        '/': TokenType.Solidus,
        ':': TokenType.Colon,
        ';': TokenType.Semicolon,
        '<': TokenType.LessThanSign,
        '=': TokenType.EqualsSign,
        '>': TokenType.GreaterThanSign,
        '?': TokenType.QuestionMark,
        '@': TokenType.CommercialAt,
        '[': TokenType.LeftSquareBracket,
        ']': TokenType.RightSquareBracket,
        '^': TokenType.CircumflexAccent,
        '_': TokenType.LowLine,
        '{': TokenType.LeftCurlyBracket,
        '|': TokenType.VerticalLine,
        '}': TokenType.RightCurlyBracket,
        '~': TokenType.Tilde
    };
    function isDecimalDigit(c) {
        return '0123456789'.indexOf(c) >= 0;
    }
    var tokens = [],
        pos,
        tn = 0,
        ln = 1;
    function _getTokens(s, syntax) {
        if (!s) return [];
        tokens = [];
        var c,
            cn;
        for (pos = 0; pos < s.length; pos++) {
            c = s.charAt(pos);
            cn = s.charAt(pos + 1);
            if (c === '/' && cn === '*') {
                parseMLComment(s);
            }
            else if (!urlMode && c === '/' && cn === '/') {
                if (['scss', 'less'].indexOf(syntax) > -1) parseSLComment(s);
                else {
                    if (blockMode > 0) parseIdentifier(s);
                    else parseSLComment(s);
                }
            }
            else if (c === '"' || c === "'") {
                parseString(s, c);
            }
            else if (c === ' ') {
                parseSpaces(s)
            }
            else if (c in Punctuation) {
                pushToken(Punctuation[c], c);
                if (c === '\n' || c === '\r') ln++;
                if (c === ')') urlMode = false;
                if (c === '{') blockMode++;
                if (c === '}') blockMode--;
            }
            else if (isDecimalDigit(c)) {
                parseDecimalNumber(s);
            }
            else {
                parseIdentifier(s);
            }
        }
        mark();
        return tokens;
    }
    function pushToken(type, value) {
        tokens.push({ tn: tn++, ln: ln, type: type, value: value });
    }
    function parseSpaces(s) {
        var start = pos;
        for (; pos < s.length; pos++) {
            if (s.charAt(pos) !== ' ') break;
        }
        pushToken(TokenType.Space, s.substring(start, pos));
        pos--;
    }
    function parseMLComment(s) {
        var start = pos;
        for (pos = pos + 2; pos < s.length; pos++) {
            if (s.charAt(pos) === '*' && s.charAt(pos + 1) === '/') {
                pos++;
                break;
            }
        }
        pushToken(TokenType.CommentML, s.substring(start, pos + 1));
    }
    function parseSLComment(s) {
        var start = pos;
        for (pos = pos + 2; pos < s.length; pos++) {
            if (s.charAt(pos) === '\n' || s.charAt(pos) === '\r') {
                break;
            }
        }
        pushToken(TokenType.CommentSL, s.substring(start, pos));
        pos--;
    }
    function parseString(s, q) {
        var start = pos;
        for (pos = pos + 1; pos < s.length; pos++) {
            if (s.charAt(pos) === '\\') pos++;
            else if (s.charAt(pos) === q) break;
        }
        pushToken(q === '"' ? TokenType.StringDQ : TokenType.StringSQ, s.substring(start, pos + 1));
    }
    function parseDecimalNumber(s) {
        var start = pos;
        for (; pos < s.length; pos++) {
            if (!isDecimalDigit(s.charAt(pos))) break;
        }
        pushToken(TokenType.DecimalNumber, s.substring(start, pos));
        pos--;
    }
    function parseIdentifier(s) {
        var start = pos;
        while (s.charAt(pos) === '/') pos++;
        for (; pos < s.length; pos++) {
            if (s.charAt(pos) === '\\') pos++;
            else if (s.charAt(pos) in Punctuation) break;
        }
        var ident = s.substring(start, pos);
        urlMode = urlMode || ident === 'url';
        pushToken(TokenType.Identifier, ident);
        pos--;
    }
    function mark() {
        var ps = [],
            sbs = [],
            cbs = [],
            t;
        for (var i = 0; i < tokens.length; i++) {
            t = tokens[i];
            switch(t.type) {
                case TokenType.LeftParenthesis:
                    ps.push(i);
                    break;
                case TokenType.RightParenthesis:
                    if (ps.length) {
                        t.left = ps.pop();
                        tokens[t.left].right = i;
                    }
                    break;
                case TokenType.LeftSquareBracket:
                    sbs.push(i);
                    break;
                case TokenType.RightSquareBracket:
                    if (sbs.length) {
                        t.left = sbs.pop();
                        tokens[t.left].right = i;
                    }
                    break;
                case TokenType.LeftCurlyBracket:
                    cbs.push(i);
                    break;
                case TokenType.RightCurlyBracket:
                    if (cbs.length) {
                        t.left = cbs.pop();
                        tokens[t.left].right = i;
                    }
                    break;
            }
        }
    }
    return function(s, syntax) {
        syntax = syntax || 'css';
        return _getTokens(s, syntax);
    };
}());
var getAST = (function() {
    var syntax,
        tokens,
        pos,
        failLN = 0,
        currentBlockLN = 0,
        needInfo = false;
    var CSSPNodeType,
        CSSPRules;
    CSSPNodeType = {
        ArgumentsType: 'arguments',
        AtkeywordType: 'atkeyword',
        AtrulebType: 'atruleb',
        AtrulerType: 'atruler',
        AtrulerqType: 'atrulerq',
        AtrulersType: 'atrulers',
        AtrulesType: 'atrules',
        AttribType: 'attrib',
        AttrselectorType: 'attrselector',
        BlockType: 'block',
        BracesType: 'braces',
        CdcType: 'cdc',
        CdoType: 'cdo',
        ClazzType: 'clazz',
        CombinatorType: 'combinator',
        CommentMLType: 'commentML',
        CommentSLType: 'commentSL',
        ConditionType: 'condition',
        DeclarationType: 'declaration',
        DecldelimType: 'decldelim',
        DefaultType: 'default',
        DelimType: 'delim',
        DimensionType: 'dimension',
        FilterType: 'filter',
        FiltervType: 'filterv',
        FunktionType: 'funktion',
        FunctionBodyType: 'functionBody',
        FunctionExpressionType: 'functionExpression',
        IdentType: 'ident',
        ImportantType: 'important',
        IncludeType :'include',
        InterpolatedVariableType: 'interpolatedVariable',
        LoopType: 'loop',
        MixinType: 'mixin',
        NamespaceType: 'namespace',
        NthType: 'nth',
        NthselectorType: 'nthselector',
        NumberType: 'number',
        OperatorType: 'operator',
        ParentSelectorType: 'parentselector',
        PercentageType: 'percentage',
        PlaceholderType: 'placeholder',
        ProgidType: 'progid',
        PseudocType: 'pseudoc',
        PseudoeType: 'pseudoe',
        PropertyType: 'property',
        RawType: 'raw',
        RulesetType: 'ruleset',
        SType: 's',
        SelectorType: 'selector',
        ShashType: 'shash',
        SimpleselectorType: 'simpleselector',
        StringType: 'string',
        StylesheetType: 'stylesheet',
        UnaryType: 'unary',
        UnknownType: 'unknown',
        UriType: 'uri',
        ValueType: 'value',
        VariableType: 'variable',
        VariablesListType: 'variableslist',
        VhashType: 'vhash'
    };
    CSSPRules = {
        'arguments': function() { if (checkArguments(pos)) return getArguments() },
        'atkeyword': function() { if (checkAtkeyword(pos)) return getAtkeyword() },
        'atruleb': function() { if (checkAtruleb(pos)) return getAtruleb() },
        'atruler': function() { if (checkAtruler(pos)) return getAtruler() },
        'atrulerq': function() { if (checkAtrulerq(pos)) return getAtrulerq() },
        'atrulers': function() { if (checkAtrulers(pos)) return getAtrulers() },
        'atrules': function() { if (checkAtrules(pos)) return getAtrules() },
        'attrib': function() { if (checkAttrib(pos)) return getAttrib() },
        'attrselector': function() { if (checkAttrselector(pos)) return getAttrselector() },
        'block': function() { if (checkBlock(pos)) return getBlock() },
        'braces': function() { if (checkBraces(pos)) return getBraces() },
        'clazz': function() { if (checkClazz(pos)) return getClazz() },
        'combinator': function() { if (checkCombinator(pos)) return getCombinator() },
        'commentML': function() { if (checkCommentML(pos)) return getCommentML() },
        'commentSL': function() { if (checkCommentSL(pos)) return getCommentSL() },
        'condition': function() { if (checkCondition(pos)) return getCondition() },
        'declaration': function() { if (checkDeclaration(pos)) return getDeclaration() },
        'decldelim': function() { if (checkDecldelim(pos)) return getDecldelim() },
        'default': function () { if (checkDefault(pos)) return getDefault() },
        'delim': function() { if (checkDelim(pos)) return getDelim() },
        'dimension': function() { if (checkDimension(pos)) return getDimension() },
        'filter': function() { if (checkFilter(pos)) return getFilter() },
        'filterv': function() { if (checkFilterv(pos)) return getFilterv() },
        'functionExpression': function() { if (checkFunctionExpression(pos)) return getFunctionExpression() },
        'funktion': function() { if (checkFunktion(pos)) return getFunktion() },
        'ident': function() { if (checkIdent(pos)) return getIdent() },
        'important': function() { if (checkImportant(pos)) return getImportant() },
        'include': function () { if (checkInclude(pos)) return getInclude() },
        'interpolatedVariable': function () { if (checkInterpolatedVariable(pos)) return getInterpolatedVariable() },
        'loop': function() { if (checkLoop(pos)) return getLoop() },
        'mixin': function () { if (checkMixin(pos)) return getMixin() },
        'namespace': function() { if (checkNamespace(pos)) return getNamespace() },
        'nth': function() { if (checkNth(pos)) return getNth() },
        'nthselector': function() { if (checkNthselector(pos)) return getNthselector() },
        'number': function() { if (checkNumber(pos)) return getNumber() },
        'operator': function() { if (checkOperator(pos)) return getOperator() },
        'parentselector': function () { if (checkParentSelector(pos)) return getParentSelector() },
        'percentage': function() { if (checkPercentage(pos)) return getPercentage() },
        'placeholder': function() { if (checkPlaceholder(pos)) return getPlaceholder() },
        'progid': function() { if (checkProgid(pos)) return getProgid() },
        'property': function() { if (checkProperty(pos)) return getProperty() },
        'pseudoc': function() { if (checkPseudoc(pos)) return getPseudoc() },
        'pseudoe': function() { if (checkPseudoe(pos)) return getPseudoe() },
        'ruleset': function() { if (checkRuleset(pos)) return getRuleset() },
        's': function() { if (checkS(pos)) return getS() },
        'selector': function() { if (checkSelector(pos)) return getSelector() },
        'shash': function() { if (checkShash(pos)) return getShash() },
        'simpleselector': function() { if (checkSimpleselector(pos)) return getSimpleSelector() },
        'string': function() { if (checkString(pos)) return getString() },
        'stylesheet': function() { if (checkStylesheet(pos)) return getStylesheet() },
        'unary': function() { if (checkUnary(pos)) return getUnary() },
        'unknown': function() { if (checkUnknown(pos)) return getUnknown() },
        'uri': function() { if (checkUri(pos)) return getUri() },
        'value': function() { if (checkValue(pos)) return getValue() },
        'variable': function () { if (checkVariable(pos)) return getVariable() },
        'variableslist': function () { if (checkVariablesList(pos)) return getVariablesList() },
        'vhash': function() { if (checkVhash(pos)) return getVhash() }
    };
    function fail(token) {
        if (token && token.ln > failLN) failLN = token.ln;
    }
    function throwError() {
        throw new Error('Please check the validity of the CSS block starting from the line #' + currentBlockLN);
    }
    function getInfo(_i) {
        return { ln: tokens[_i].ln, tn: tokens[_i].tn };
    }
    function _getAST(_syntax, _tokens, rule, _needInfo) {
        syntax = _syntax;
        tokens = _tokens;
        rule = rule || 'stylesheet';
        needInfo = _needInfo;
        pos = 0;
        markSC();
        return CSSPRules[rule]();
    }
    function checkAny(_i) {
        return checkBraces(_i) ||
            checkString(_i) ||
            checkVariablesList(_i) ||
            checkVariable(_i) ||
            checkPlaceholder(_i) ||
            checkPercentage(_i) ||
            checkDimension(_i) ||
            checkNumber(_i) ||
            checkUri(_i) ||
            checkFunctionExpression(_i) ||
            checkFunktion(_i) ||
            checkIdent(_i) ||
            checkClazz(_i) ||
            checkUnary(_i);
    }
    function getAny() {
        if (checkBraces(pos)) return getBraces();
        else if (checkString(pos)) return getString();
        else if (checkVariablesList(pos)) return getVariablesList();
        else if (checkVariable(pos)) return getVariable();
        else if (checkPlaceholder(pos)) return getPlaceholder();
        else if (checkPercentage(pos)) return getPercentage();
        else if (checkDimension(pos)) return getDimension();
        else if (checkNumber(pos)) return getNumber();
        else if (checkUri(pos)) return getUri();
        else if (checkFunctionExpression(pos)) return getFunctionExpression();
        else if (checkFunktion(pos)) return getFunktion();
        else if (checkIdent(pos)) return getIdent();
        else if (checkClazz(pos)) return getClazz();
        else if (checkUnary(pos)) return getUnary();
    }
    function checkArguments(_i) {
        var start = _i;
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (_i >= tokens.length ||
            (tokens[_i].type !== TokenType.LeftParenthesis)) return fail(tokens[_i]);
        _i++;
        while (_i < tokens[start].right) {
            if (l = _checkArgument(_i)) _i +=l;
            else return fail(tokens[_i]);
        }
        return tokens[start].right - start + 1;
    }
    function getArguments() {
        var startPos = pos,
            arguments = [];
        pos++;
        while (x = _getArgument()) {
            if ((needInfo && typeof x[1] === 'string') || typeof x[0] === 'string') arguments.push(x);
            else arguments = arguments.concat(x);
        }
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.ArgumentsType].concat(arguments) :
            [CSSPNodeType.ArgumentsType].concat(arguments);
    }
    function _checkArgument(_i) {
        return checkDeclaration(_i) ||
            checkVariablesList(_i) ||
            checkVariable(_i) ||
            checkSC(_i) ||
            checkDelim(_i) ||
            checkDecldelim(_i) ||
            checkString(_i) ||
            checkPercentage(_i) ||
            checkDimension(_i) ||
            checkNumber(_i) ||
            checkUri(_i) ||
            checkIdent(_i) ||
            checkVhash(_i);
    }
    function _getArgument() {
        if (checkDeclaration(pos)) return getDeclaration();
        else if (checkVariablesList(pos)) return getVariablesList();
        else if (checkVariable(pos)) return getVariable();
        else if (checkSC(pos)) return getSC();
        else if (checkDelim(pos)) return getDelim();
        else if (checkDecldelim(pos)) return getDecldelim();
        else if (checkString(pos)) return getString();
        else if (checkPercentage(pos)) return getPercentage();
        else if (checkDimension(pos)) return getDimension();
        else if (checkNumber(pos)) return getNumber();
        else if (checkUri(pos)) return getUri();
        else if (checkIdent(pos)) return getIdent();
        else if (checkVhash(pos)) return getVhash();
    }
    function checkAtkeyword(_i) {
        var l;
        if (tokens[_i++].type !== TokenType.CommercialAt) return fail(tokens[_i - 1]);
        if (l = checkIdent(_i)) return l + 1;
        return fail(tokens[_i]);
    }
    function getAtkeyword() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.AtkeywordType, getIdent()]:
            [CSSPNodeType.AtkeywordType, getIdent()];
    }
    function checkAttrib(_i) {
        if (tokens[_i].type !== TokenType.LeftSquareBracket) return fail(tokens[_i]);
        if (!tokens[_i].right) return fail(tokens[_i]);
        return tokens[_i].right - _i + 1;
    }
    function checkAttrib1(_i) {
        var start = _i,
            l;
        _i++;
        l = checkSC(_i);
        if (l) _i += l;
        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkAttrselector(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if ((l = checkIdent(_i)) || (l = checkString(_i))) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (tokens[_i].type === TokenType.RightSquareBracket) return _i - start;
        return fail(tokens[_i]);
    }
    function getAttrib1() {
        var startPos = pos;
        pos++;
        var a = (needInfo? [getInfo(startPos), CSSPNodeType.AttribType] : [CSSPNodeType.AttribType])
            .concat(getSC())
            .concat([getIdent()])
            .concat(getSC())
            .concat([getAttrselector()])
            .concat(getSC())
            .concat([checkString(pos)? getString() : getIdent()])
            .concat(getSC());
        pos++;
        return a;
    }
    function checkAttrib2(_i) {
        var start = _i;
        _i++;
        var l = checkSC(_i);
        if (l) _i += l;
        if (l = checkIdent(_i)) _i += l;
        if (l = checkSC(_i)) _i += l;
        if (tokens[_i].type === TokenType.RightSquareBracket) return _i - start;
        return fail(tokens[_i]);
    }
    function getAttrib2() {
        var startPos = pos;
        pos++;
        var a = (needInfo? [getInfo(startPos), CSSPNodeType.AttribType] : [CSSPNodeType.AttribType])
            .concat(getSC())
            .concat([getIdent()])
            .concat(getSC());
        pos++;
        return a;
    }
    function getAttrib() {
        if (checkAttrib1(pos)) return getAttrib1();
        if (checkAttrib2(pos)) return getAttrib2();
    }
    function checkAttrselector(_i) {
        if (tokens[_i].type === TokenType.EqualsSign) return 1;
        if (tokens[_i].type === TokenType.VerticalLine && (!tokens[_i + 1] || tokens[_i + 1].type !== TokenType.EqualsSign)) return 1;
        if (!tokens[_i + 1] || tokens[_i + 1].type !== TokenType.EqualsSign) return fail(tokens[_i]);
        switch(tokens[_i].type) {
            case TokenType.Tilde:
            case TokenType.CircumflexAccent:
            case TokenType.DollarSign:
            case TokenType.Asterisk:
            case TokenType.VerticalLine:
                return 2;
        }
        return fail(tokens[_i]);
    }
    function getAttrselector() {
        var startPos = pos,
            s = tokens[pos++].value;
        if (tokens[pos] && tokens[pos].type === TokenType.EqualsSign) s += tokens[pos++].value;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.AttrselectorType, s] :
            [CSSPNodeType.AttrselectorType, s];
    }
    function checkAtrule(_i) {
        var l;
        if (tokens[_i].atrule_l !== undefined) return tokens[_i].atrule_l;
        if (l = checkAtruler(_i)) tokens[_i].atrule_type = 1;
        else if (l = checkAtruleb(_i)) tokens[_i].atrule_type = 2;
        else if (l = checkAtrules(_i)) tokens[_i].atrule_type = 3;
        else return fail(tokens[_i]);
        tokens[_i].atrule_l = l;
        return l;
    }
    function getAtrule() {
        switch (tokens[pos].atrule_type) {
            case 1: return getAtruler();
            case 2: return getAtruleb();
            case 3: return getAtrules();
        }
    }
    function checkAtruleb(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkTsets(_i)) _i += l;
        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function getAtruleb() {
        return (needInfo?
            [getInfo(pos), CSSPNodeType.AtrulebType, getAtkeyword()] :
            [CSSPNodeType.AtrulebType, getAtkeyword()])
            .concat(getTsets())
            .concat([getBlock()]);
    }
    function checkAtruler(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkAtrulerq(_i)) _i += l;
        if (_i < tokens.length && tokens[_i].type === TokenType.LeftCurlyBracket) _i++;
        else return fail(tokens[_i]);
        if (l = checkAtrulers(_i)) _i += l;
        if (_i < tokens.length && tokens[_i].type === TokenType.RightCurlyBracket) _i++;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function getAtruler() {
        var atruler = needInfo?
            [getInfo(pos), CSSPNodeType.AtrulerType, getAtkeyword(), getAtrulerq()] :
            [CSSPNodeType.AtrulerType, getAtkeyword(), getAtrulerq()];
        pos++;
        atruler.push(getAtrulers());
        pos++;
        return atruler;
    }
    function checkAtrulerq(_i) {
        return checkTsets(_i);
    }
    function getAtrulerq() {
        return (needInfo?
            [getInfo(pos), CSSPNodeType.AtrulerqType] :
            [CSSPNodeType.AtrulerqType])
            .concat(getTsets());
    }
    function checkAtrulers(_i) {
        var start = _i,
            l;
        if (l = checkSC(_i)) _i += l;
        while ((l = checkRuleset(_i)) || (l = checkAtrule(_i)) || (l = checkSC(_i))) {
            _i += l;
        }
        tokens[_i].atrulers_end = 1;
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function getAtrulers() {
        var atrulers = (needInfo?
            [getInfo(pos), CSSPNodeType.AtrulersType] :
            [CSSPNodeType.AtrulersType])
            .concat(getSC());
        while (!tokens[pos].atrulers_end) {
            if (checkSC(pos)) {
                atrulers = atrulers.concat(getSC());
            } else if (checkRuleset(pos)) {
                atrulers.push(getRuleset());
            } else {
                atrulers.push(getAtrule());
            }
        }
        return atrulers.concat(getSC());
    }
    function checkAtrules(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkTsets(_i)) _i += l;
        if (_i >= tokens.length) return _i - start;
        return _i - start;
    }
    function getAtrules() {
        var x = needInfo ?
            [getInfo(pos), CSSPNodeType.AtrulesType, getAtkeyword()] :
            [CSSPNodeType.AtrulesType, getAtkeyword()];
        return x.concat(getTsets());
    }
    function checkBlock(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.LeftCurlyBracket) return tokens[_i].right - _i + 1;
        return fail(tokens[_i]);
    }
    function getBlock() {
        var block = needInfo? [getInfo(pos), CSSPNodeType.BlockType] : [CSSPNodeType.BlockType],
            end = tokens[pos].right;
        pos++;
        while (pos < end) {
            if (checkBlockdecl(pos)) block = block.concat(getBlockdecl());
            else throwError();
        }
        pos = end + 1;
        return block;
    }
    function checkBlockdecl(_i) {
        var l;
        if (l = _checkBlockdecl0(_i)) tokens[_i].bd_type = 1;
        else if (l = _checkBlockdecl1(_i)) tokens[_i].bd_type = 2;
        else if (l = _checkBlockdecl2(_i)) tokens[_i].bd_type = 3;
        else if (l = _checkBlockdecl3(_i)) tokens[_i].bd_type = 4;
        else return fail(tokens[_i]);
        return l;
    }
    function getBlockdecl() {
        switch (tokens[pos].bd_type) {
            case 1: return _getBlockdecl0();
            case 2: return _getBlockdecl1();
            case 3: return _getBlockdecl2();
            case 4: return _getBlockdecl3();
        }
    }
    function _checkBlockdecl0(_i) {
        var start = _i,
            l;
        if (l = checkSC(_i)) _i += l;
        if (l = checkCondition(_i)) tokens[_i].bd_kind = 1;
        else if (l = checkInclude(_i)) tokens[_i].bd_kind = 2;
        else if (l = checkLoop(_i)) tokens[_i].bd_kind = 3;
        else if (l = checkFilter(_i)) tokens[_i].bd_kind = 4;
        else if (l = checkDeclaration(_i)) tokens[_i].bd_kind = 5;
        else if (l = checkAtrule(_i)) tokens[_i].bd_kind = 6;
        else if (l = checkRuleset(_i)) tokens[_i].bd_kind = 7;
        else return fail(tokens[_i]);
        _i += l;
        if (_i < tokens.length && (l = checkDecldelim(_i))) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function _getBlockdecl0() {
        var sc = getSC(),
            x;
        switch (tokens[pos].bd_kind) {
            case 1:
                x = getCondition();
                break;
            case 2:
                x = getInclude();
                break;
            case 3:
                x = getLoop();
                break;
            case 4:
                x = getFilter();
                break;
            case 5:
                x = getDeclaration();
                break;
            case 6:
                x = getAtrule();
                break;
            case 7:
                x = getRuleset();
                break;
        }
        return sc
            .concat([x])
            .concat([getDecldelim()])
            .concat(getSC());
    }
    function _checkBlockdecl1(_i) {
        var start = _i,
            l;
        if (l = checkSC(_i)) _i += l;
        if (l = checkCondition(_i)) tokens[_i].bd_kind = 1;
        else if (l = checkInclude(_i)) tokens[_i].bd_kind = 2;
        else if (l = checkLoop(_i)) tokens[_i].bd_kind = 3;
        else if (l = checkFilter(_i)) tokens[_i].bd_kind = 4;
        else if (l = checkDeclaration(_i)) tokens[_i].bd_kind = 5;
        else if (l = checkAtrule(_i)) tokens[_i].bd_kind = 6;
        else if (l = checkRuleset(_i)) tokens[_i].bd_kind = 7;
        else return fail(tokens[_i]);
        _i += l;
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function _getBlockdecl1() {
        var sc = getSC(),
            x;
        switch (tokens[pos].bd_kind) {
            case 1:
                x = getCondition();
                break;
            case 2:
                x = getInclude();
                break;
            case 3:
                x = getLoop();
                break;
            case 4:
                x = getFilter();
                break;
            case 5:
                x = getDeclaration();
                break;
            case 6:
                x = getAtrule();
                break;
            case 7:
                x = getRuleset();
                break;
        }
        return sc
            .concat([x])
            .concat(getSC());
    }
    function _checkBlockdecl2(_i) {
        var start = _i,
            l;
        if (l = checkSC(_i)) _i += l;
        if (l = checkDecldelim(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function _getBlockdecl2() {
        return getSC()
            .concat([getDecldelim()])
            .concat(getSC());
    }
    function _checkBlockdecl3(_i) {
        return checkSC(_i);
    }
    function _getBlockdecl3() {
        return getSC();
    }
    function checkBraces(_i) {
        if (_i >= tokens.length ||
            (tokens[_i].type !== TokenType.LeftParenthesis &&
                tokens[_i].type !== TokenType.LeftSquareBracket)
            ) return fail(tokens[_i]);
        return tokens[_i].right - _i + 1;
    }
    function getBraces() {
        var startPos = pos,
            left = pos,
            right = tokens[pos].right;
        pos++;
        var tsets = getTsets();
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.BracesType, tokens[left].value, tokens[right].value].concat(tsets) :
            [CSSPNodeType.BracesType, tokens[left].value, tokens[right].value].concat(tsets);
    }
    function checkClazz(_i) {
        var l;
        if (_i >= tokens.length) return fail(tokens[_i]);
        if (tokens[_i].clazz_l) return tokens[_i].clazz_l;
        if (tokens[_i].type === TokenType.FullStop) {
            if (l = checkInterpolatedVariable(_i + 1) || checkIdent(_i + 1)) {
                tokens[_i].clazz_l = l + 1;
                return l + 1;
            }
        }
        return fail(tokens[_i]);
    }
    function getClazz() {
        var startPos = pos,
            x;
        pos++;
        x = checkInterpolatedVariable(pos) ? getInterpolatedVariable() : getIdent();
        return needInfo?
            [getInfo(startPos), CSSPNodeType.ClazzType, x] :
            [CSSPNodeType.ClazzType, x];
    }
    function checkCombinator(_i) {
        if (tokens[_i].type === TokenType.PlusSign ||
            tokens[_i].type === TokenType.GreaterThanSign ||
            tokens[_i].type === TokenType.Tilde) return 1;
        return fail(tokens[_i]);
    }
    function getCombinator() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.CombinatorType, tokens[pos++].value] :
            [CSSPNodeType.CombinatorType, tokens[pos++].value];
    }
    function checkCommentML(_i) {
        if (tokens[_i].type === TokenType.CommentML) return 1;
        return fail(tokens[_i]);
    }
    function getCommentML() {
        var startPos = pos,
            s = tokens[pos].value.substring(2),
            l = s.length;
        if (s.charAt(l - 2) === '*' && s.charAt(l - 1) === '/') s = s.substring(0, l - 2);
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.CommentMLType, s] :
            [CSSPNodeType.CommentMLType, s];
    }
    function checkCommentSL(_i) {
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (_i < tokens.length && tokens[_i].type === TokenType.CommentSL) return 1;
        return fail(tokens[_i]);
    }
    function getCommentSL() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.CommentSLType, tokens[pos++].value.substring(2)] :
            [CSSPNodeType.CommentSLType, tokens[pos++].value.substring(2)];
    }
    function checkCondition(_i) {
        if (syntax === 'scss') return _checkCondition0(_i);
        else if (syntax === 'less') return _checkCondition1(_i);
        else return fail(tokens[_i]);
    }
    function getCondition() {
        return syntax === 'scss' ? _getCondition0() : _getCondition1();
    }
    function _checkCondition0(_i) {
        var start = _i;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (['if', 'else'].indexOf(tokens[start + 1].value) < 0) return fail(tokens[start]);
        while (_i < tokens.length) {
            if (l = checkBlock(_i)) break;
            else if (l = checkVariable(_i) || checkIdent(_i) || checkSC(_i) ||
                checkNumber(_i) || checkOperator(_i) || checkCombinator(_i) ||
                checkString(_i))
                _i += l;
            else return fail(tokens[_i]);
        }
        return _i - start;
    }
    function _getCondition0() {
        var startPos = pos,
            x = [];
        x.push(getAtkeyword());
        while (pos < tokens.length) {
            if (l = checkBlock(pos)) break;
            else if (checkVariable(pos)) x.push(getVariable());
            else if (checkIdent(pos)) x.push(getIdent());
            else if (checkNumber(pos)) x.push(getNumber());
            else if (checkOperator(pos)) x.push(getOperator());
            else if (checkCombinator(pos)) x.push(getCombinator());
            else if (checkSC(pos)) x = x.concat(getSC());
            else if (checkString(pos)) x.push(getString());
        }
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.ConditionType] :
            [CSSPNodeType.ConditionType])
            .concat(x);
    }
    function _checkCondition1(_i) {
        var start = _i;
        if (syntax !== 'less') return fail(tokens[_i]);
        if ((l = checkIdent(_i)) && tokens[_i].value === 'when') _i += l;
        else return fail(tokens[_i]);
        while (_i < tokens.length) {
            if (l = checkBlock(_i)) break;
            else if (l = checkFunktion(_i) || checkBraces(_i) ||
                checkVariable(_i) || checkIdent(_i) || checkSC(_i) ||
                checkNumber(_i) || checkDelim(_i) || checkOperator(_i) ||
                checkCombinator(_i) || checkString(_i))
                _i += l;
            else return fail(tokens[_i]);
        }
        return _i - start;
    }
    function _getCondition1() {
        var startPos = pos,
            x = [];
        x.push(getIdent());
        while (pos < tokens.length) {
            if (l = checkBlock(pos)) break;
            else if (checkFunktion(pos)) x.push(getFunktion());
            else if (checkBraces(pos)) x.push(getBraces());
            else if (checkVariable(pos)) x.push(getVariable());
            else if (checkIdent(pos)) x.push(getIdent());
            else if (checkNumber(pos)) x.push(getNumber());
            else if (checkDelim(pos)) x.push(getDelim());
            else if (checkOperator(pos)) x.push(getOperator());
            else if (checkCombinator(pos)) x.push(getCombinator());
            else if (checkSC(pos)) x = x.concat(getSC());
            else if (checkString(pos)) x.push(getString());
        }
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.ConditionType] :
            [CSSPNodeType.ConditionType])
            .concat(x);
    }
    function checkDeclaration(_i) {
        var start = _i,
            l;
        if (l = checkProperty(_i)) _i += l;
        else return fail(tokens[_i]);
        if (_i < tokens.length && tokens[_i].type === TokenType.Colon) _i++;
        else return fail(tokens[_i]);
        if (l = checkValue(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function getDeclaration() {
        var declaration = needInfo?
            [getInfo(pos), CSSPNodeType.DeclarationType, getProperty()] :
            [CSSPNodeType.DeclarationType, getProperty()];
        pos++;
        declaration.push(getValue());
        return declaration;
    }
    function checkDecldelim(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.Semicolon) return 1;
        return fail(tokens[_i]);
    }
    function getDecldelim() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.DecldelimType] :
            [CSSPNodeType.DecldelimType];
    }
    function checkDefault(_i) {
        var start = _i,
            l;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if (tokens[_i++].type !== TokenType.ExclamationMark) return fail(tokens[_i - 1]);
        if (l = checkSC(_i)) _i += l;
        if (tokens[_i].value !== 'default') return fail(tokens[_i]);
        return _i - start + 1;
    }
    function getDefault() {
        var startPos = pos;
        pos++;
        var sc = getSC();
        pos++;
        return (needInfo? [getInfo(startPos), CSSPNodeType.DefaultType] : [CSSPNodeType.DefaultType]).concat(sc);
    }
    function checkDelim(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.Comma) return 1;
        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);
        return fail(tokens[_i]);
    }
    function getDelim() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.DelimType] :
            [CSSPNodeType.DelimType];
    }
    function checkDimension(_i) {
        var ln = checkNumber(_i),
            li;
        if (!ln || (ln && _i + ln >= tokens.length)) return fail(tokens[_i]);
        if (li = checkNmName2(_i + ln)) return ln + li;
        return fail(tokens[_i]);
    }
    function getDimension() {
        var startPos = pos,
            n = getNumber(),
            dimension = needInfo ?
                [getInfo(pos), CSSPNodeType.IdentType, getNmName2()] :
                [CSSPNodeType.IdentType, getNmName2()];
        return needInfo?
            [getInfo(startPos), CSSPNodeType.DimensionType, n, dimension] :
            [CSSPNodeType.DimensionType, n, dimension];
    }
    function checkFilter(_i) {
        var start = _i,
            l;
        if (l = checkFilterp(_i)) _i += l;
        else return fail(tokens[_i]);
        if (tokens[_i].type === TokenType.Colon) _i++;
        else return fail(tokens[_i]);
        if (l = checkFilterv(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function getFilter() {
        var filter = needInfo?
            [getInfo(pos), CSSPNodeType.FilterType, getFilterp()] :
            [CSSPNodeType.FilterType, getFilterp()];
        pos++;
        filter.push(getFilterv());
        return filter;
    }
    function checkFilterp(_i) {
        var start = _i,
            l,
            x;
        if (_i < tokens.length) {
            if (tokens[_i].value === 'filter') l = 1;
            else {
                x = joinValues2(_i, 2);
                if (x === '-filter' || x === '_filter' || x === '*filter') l = 2;
                else {
                    x = joinValues2(_i, 4);
                    if (x === '-ms-filter') l = 4;
                    else return fail(tokens[_i]);
                }
            }
            tokens[start].filterp_l = l;
            _i += l;
            if (checkSC(_i)) _i += l;
            return _i - start;
        }
        return fail(tokens[_i]);
    }
    function getFilterp() {
        var startPos = pos,
            x = joinValues2(pos, tokens[pos].filterp_l),
            ident = needInfo? [getInfo(startPos), CSSPNodeType.IdentType, x] : [CSSPNodeType.IdentType, x];
        pos += tokens[pos].filterp_l;
        return (needInfo? [getInfo(startPos), CSSPNodeType.PropertyType, ident] : [CSSPNodeType.PropertyType, ident])
            .concat(getSC());
    }
    function checkFilterv(_i) {
        var start = _i,
            l;
        if (l = checkProgid(_i)) _i += l;
        else return fail(tokens[_i]);
        while (l = checkProgid(_i)) {
            _i += l;
        }
        tokens[start].last_progid = _i;
        if (_i < tokens.length && (l = checkSC(_i))) _i += l;
        if (_i < tokens.length && (l = checkImportant(_i) || checkDefault(_i))) _i += l;
        return _i - start;
    }
    function getFilterv() {
        var filterv = needInfo? [getInfo(pos), CSSPNodeType.FiltervType] : [CSSPNodeType.FiltervType],
            last_progid = tokens[pos].last_progid;
        while (pos < last_progid) {
            filterv.push(getProgid());
        }
        filterv = filterv.concat(checkSC(pos) ? getSC() : []);
        if (pos < tokens.length && checkImportant(pos)) filterv.push(getImportant());
        if (pos < tokens.length && checkDefault(pos)) filterv.push(getDefault());
        return filterv;
    }
    function checkFunctionExpression(_i) {
        var start = _i;
        if (!tokens[_i] || tokens[_i++].value !== 'expression') return fail(tokens[_i - 1]);
        if (!tokens[_i] || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i]);
        return tokens[_i].right - start + 1;
    }
    function getFunctionExpression() {
        var startPos = pos;
        pos++;
        var e = joinValues(pos + 1, tokens[pos].right - 1);
        pos = tokens[pos].right + 1;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.FunctionExpressionType, e] :
            [CSSPNodeType.FunctionExpressionType, e];
    }
    function checkFunktion(_i) {
        var start = _i,
            l;
        if (l = checkIdent(_i)) _i +=l;
        else return fail(tokens[_i]);
        if (_i >= tokens.length || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i - 1]);
        return tokens[_i].right - start + 1;
    }
    function getFunktion() {
        var startPos = pos,
            ident = getIdent();
        pos++;
        var body = ident[needInfo? 2 : 1] !== 'not'?
            getFunctionBody() :
            getNotFunctionBody();
        return needInfo?
            [getInfo(startPos), CSSPNodeType.FunktionType, ident, body] :
            [CSSPNodeType.FunktionType, ident, body];
    }
    function getFunctionBody() {
        var startPos = pos,
            body = [],
            x;
        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkDeclaration(pos)) body.push(getDeclaration());
            else if (checkTset(pos)) {
                x = getTset();
                if ((needInfo && typeof x[1] === 'string') || typeof x[0] === 'string') body.push(x);
                else body = body.concat(x);
            } else if (checkClazz(pos)) {
                body.push(getClazz());
            } else {
                throwError();
            }
        }
        pos++;
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.FunctionBodyType] :
            [CSSPNodeType.FunctionBodyType]
            ).concat(body);
    }
    function getNotFunctionBody() {
        var startPos = pos,
            body = [];
        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkSimpleselector(pos)) {
                body.push(getSimpleSelector());
            } else {
                throwError();
            }
        }
        pos++;
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.FunctionBodyType] :
            [CSSPNodeType.FunctionBodyType]
            ).concat(body);
    }
    function checkIdent(_i) {
        var l;
        if (_i >= tokens.length) return fail(tokens[_i]);
        var start = _i,
            wasIdent;
        if (tokens[_i].type === TokenType.LowLine) return checkIdentLowLine(_i);
        if (tokens[_i].type === TokenType.HyphenMinus ||
            tokens[_i].type === TokenType.Identifier ||
            tokens[_i].type === TokenType.DollarSign ||
            tokens[_i].type === TokenType.Asterisk) _i++;
        else return fail(tokens[_i]);
        wasIdent = tokens[_i - 1].type === TokenType.Identifier;
        for (; _i < tokens.length; _i++) {
            if (l = checkInterpolatedVariable(_i)) _i += l;
            if (!tokens[_i]) break;
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.LowLine) {
                if (tokens[_i].type !== TokenType.Identifier &&
                    (tokens[_i].type !== TokenType.DecimalNumber || !wasIdent)
                    ) break;
                else wasIdent = true;
            }
        }
        if (!wasIdent && tokens[start].type !== TokenType.Asterisk) return fail(tokens[_i]);
        tokens[start].ident_last = _i - 1;
        return _i - start;
    }
    function checkIdentLowLine(_i) {
        var start = _i;
        _i++;
        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.DecimalNumber &&
                tokens[_i].type !== TokenType.LowLine &&
                tokens[_i].type !== TokenType.Identifier) break;
        }
        tokens[start].ident_last = _i - 1;
        return _i - start;
    }
    function getIdent() {
        var startPos = pos,
            s = joinValues(pos, tokens[pos].ident_last);
        pos = tokens[pos].ident_last + 1;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.IdentType, s] :
            [CSSPNodeType.IdentType, s];
    }
    function checkImportant(_i) {
        var start = _i,
            l;
        if (!tokens[_i] || tokens[_i].type !== TokenType.ExclamationMark) return fail(tokens[_i - 1]);
        _i++;
        if (l = checkSC(_i)) _i += l;
        if (tokens[_i].value !== 'important') return fail(tokens[_i]);
        return _i - start + 1;
    }
    function getImportant() {
        var startPos = pos;
        pos++;
        var sc = getSC();
        pos++;
        return (needInfo? [getInfo(startPos), CSSPNodeType.ImportantType] : [CSSPNodeType.ImportantType]).concat(sc);
    }
    function checkInclude(_i) {
        var l;
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (syntax === 'scss') {
            if (l = _checkInclude0(_i)) tokens[_i].include_type = 1;
            else if (l = _checkInclude1(_i)) tokens[_i].include_type = 2;
            else if (l = _checkInclude2(_i)) tokens[_i].include_type = 3;
        } else if (syntax === 'less') {
            if (l = _checkInclude3(_i)) tokens[_i].include_type = 4;
            else if (l = _checkInclude4(_i)) tokens[_i].include_type = 5;
        } else return fail(tokens[_i]);
        return l;
    }
    function getInclude() {
        switch (tokens[pos].include_type) {
            case 1: return _getInclude0();
            case 2: return _getInclude1();
            case 3: return _getInclude2();
            case 4: return _getInclude3();
            case 5: return _getInclude4();
        }
    }
    function _checkInclude0(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (['include', 'extend'].indexOf(tokens[start + 1].value) < 0) return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkIncludeSelector(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkArguments(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function _getInclude0() {
        var startPos = pos,
            x = [];
        x.push(getAtkeyword());
        x = x.concat(getSC());
        x.push(getIncludeSelector());
        if (checkSC(pos)) x = x.concat(getSC());
        x.push(getArguments());
        if (checkSC(pos)) x = x.concat(getSC());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.IncludeType] :
            [CSSPNodeType.IncludeType])
            .concat(x);
    }
    function _checkInclude1(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (['include', 'extend'].indexOf(tokens[start + 1].value) < 0) return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkIncludeSelector(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function _getInclude1() {
        var startPos = pos,
            x = [];
        x.push(getAtkeyword());
        x = x.concat(getSC());
        x.push(getIncludeSelector());
        if (checkSC(pos)) x = x.concat(getSC());
        x.push(getBlock());
        if (checkSC(pos)) x = x.concat(getSC());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.IncludeType] :
            [CSSPNodeType.IncludeType])
            .concat(x);
    }
    function _checkInclude2(_i) {
        var start = _i,
            l;
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (['include', 'extend'].indexOf(tokens[start + 1].value) < 0) return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkIncludeSelector(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function _getInclude2() {
        var startPos = pos,
            x = [];
        x.push(getAtkeyword());
        x = x.concat(getSC());
        x.push(getIncludeSelector());
        if (checkSC(pos)) x = x.concat(getSC());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.IncludeType] :
            [CSSPNodeType.IncludeType])
            .concat(x);
    }
    function _checkInclude3(_i) {
        var start = _i,
            l;
        if (l = checkClazz(_i) || checkShash(_i)) _i += l;
        else return fail(tokens[_i]);
        while (_i < tokens.length) {
            if (l = checkClazz(_i) || checkShash(_i) || checkSC(_i)) _i += l;
            else if (tokens[_i].type == TokenType.GreaterThanSign) _i ++;
            else break;
        }
        if (l = checkArguments(_i)) _i += l;
        else return fail(tokens[_i]);
        if (tokens[_i] && (l = checkSC(_i))) _i += l;
        if (tokens[_i] && (l = checkImportant(_i))) _i += l;
        return _i - start;
    }
    function _getInclude3() {
        var startPos = pos,
            x = [];
        x.push(checkClazz(pos) ? getClazz() : getShash());
        while (pos < tokens.length) {
            if (checkClazz(pos)) x.push(getClazz());
            else if (checkShash(pos)) x.push(getShash());
            else if (checkSC(pos)) x = x.concat(getSC());
            else if (checkOperator(pos)) x.push(getOperator());
            else break;
        }
        x.push(getArguments());
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkImportant(pos)) x.push(getImportant());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.IncludeType] :
            [CSSPNodeType.IncludeType])
            .concat(x);
    }
    function _checkInclude4(_i) {
        var start = _i,
            l;
        if (l = checkClazz(_i) || checkShash(_i)) _i += l;
        else return fail(tokens[_i]);
        while (_i < tokens.length) {
            if (l = checkClazz(_i) || checkShash(_i) || checkSC(_i)) _i += l;
            else if (tokens[_i].type == TokenType.GreaterThanSign) _i ++;
            else break;
        }
        return _i - start;
    }
    function _getInclude4() {
        var startPos = pos,
            x = [];
        x.push(checkClazz(pos) ? getClazz() : getShash());
        while (pos < tokens.length) {
            if (checkClazz(pos)) x.push(getClazz());
            else if (checkShash(pos)) x.push(getShash());
            else if (checkSC(pos)) x = x.concat(getSC());
            else if (checkOperator(pos)) x.push(getOperator());
            else break;
        }
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.IncludeType] :
            [CSSPNodeType.IncludeType])
            .concat(x);
    }
    function checkIncludeSelector(_i) {
        var start = _i,
            l;
        while (_i < tokens.length) {
            if (l = _checkSimpleSelector1(_i)) _i += l;
            else break;
        }
        if (_i - start) return _i - start;
        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);
        return fail(tokens[_i]);
    }
    function getIncludeSelector() {
        var ss = needInfo? [getInfo(pos), CSSPNodeType.SimpleselectorType] : [CSSPNodeType.SimpleselectorType],
            t;
        while (pos < tokens.length && _checkSimpleSelector1(pos)) {
            t = _getSimpleSelector1();
            if ((needInfo && typeof t[1] === 'string') || typeof t[0] === 'string') ss.push(t);
            else ss = ss.concat(t);
        }
        return ss;
    }
    function checkInterpolatedVariable(_i) {
        if (syntax === 'scss') return _checkInterpolatedVariable0(_i);
        else if (syntax === 'less') return _checkInterpolatedVariable1(_i);
        else return fail(tokens[_i]);
    }
    function getInterpolatedVariable() {
        return syntax === 'scss' ? _getInterpolatedVariable0() : _getInterpolatedVariable1();
    }
    function _checkInterpolatedVariable0(_i) {
        var start = _i,
            l;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.NumberSign ||
            !tokens[_i + 1] ||
            tokens[_i + 1].type !== TokenType.LeftCurlyBracket ||
            !tokens[_i + 2] ||
            tokens[_i + 2].type !== TokenType.DollarSign) return fail(tokens[_i - 1]);
        _i += 3;
        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.RightCurlyBracket) return fail(tokens[_i - 1]);
        return _i - start + 1;
    }
    function _getInterpolatedVariable0() {
        var startPos = pos,
            x;
        pos += 3;
        x = getIdent();
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.InterpolatedVariableType, x] :
            [CSSPNodeType.InterpolatedVariableType, x];
    }
    function _checkInterpolatedVariable1(_i) {
        var start = _i,
            l;
        if (syntax !== 'less') return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.CommercialAt ||
            !tokens[_i + 1] ||
            tokens[_i + 1].type !== TokenType.LeftCurlyBracket) return fail(tokens[_i - 1]);
        _i += 2;
        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.RightCurlyBracket) return fail(tokens[_i - 1]);
        return _i - start + 1;
    }
    function _getInterpolatedVariable1() {
        var startPos = pos,
            x;
        pos += 2;
        x = getIdent();
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.InterpolatedVariableType, x] :
            [CSSPNodeType.InterpolatedVariableType, x];
    }
    function checkLoop(_i) {
        var start = _i,
            l;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if (l = checkAtkeyword(_i)) _i += l;
        else return fail(tokens[_i]);
        if (['for', 'each', 'while'].indexOf(tokens[start + 1].value) < 0) return fail(tokens[start]);
        while (_i < tokens.length) {
            if (l = checkBlock(_i)) {
                _i += l;
                break;
            }
            else if (l = checkVariable(_i) || checkIdent(_i) || checkSC(_i) ||
                checkNumber(_i) || checkOperator(_i) || checkCombinator(_i) ||
                checkString(_i))
                _i += l;
            else return fail(tokens[_i]);
        }
        return _i - start;
    }
    function getLoop() {
        var startPos = pos,
            x = [];
        x.push(getAtkeyword());
        while (pos < tokens.length) {
            if (l = checkBlock(pos)) {
                x.push(getBlock());
                break;
            }
            else if (checkVariable(pos)) x.push(getVariable());
            else if (checkIdent(pos)) x.push(getIdent());
            else if (checkNumber(pos)) x.push(getNumber());
            else if (checkOperator(pos)) x.push(getOperator());
            else if (checkCombinator(pos)) x.push(getCombinator());
            else if (checkSC(pos)) x = x.concat(getSC());
            else if (checkString(pos)) x.push(getString());
        }
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.LoopType] :
            [CSSPNodeType.LoopType])
            .concat(x);
    }
    function checkMixin(_i) {
        var start = _i,
            l;
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (l = _checkMixin0(_i)) tokens[_i].mixin_type = 1;
        else if (l = _checkMixin1(_i)) tokens[_i].mixin_type = 2;
        else return fail(tokens[_i]);
        _i += l;
        return _i - start;
    }
    function getMixin() {
        switch (tokens[pos].mixin_type) {
            case 1:
                return _getMixin0();
                break;
            case 2:
                return _getMixin1();
                break;
        }
    }
    function _checkMixin0(_i) {
        var start = _i,
            l;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if ((l = checkAtkeyword(_i)) && tokens[_i + 1].value === 'mixin') _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkArguments(_i)) _i += l;
        if (l = checkSC(_i)) _i += l;
        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function _getMixin0() {
        var startPos = pos;
        var x = [getAtkeyword()];
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkIdent(pos)) x.push(getIdent());
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkArguments(pos)) x.push(getArguments());
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkBlock(pos)) x.push(getBlock());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.MixinType] :
            [CSSPNodeType.MixinType])
            .concat(x);
    }
    function _checkMixin1(_i) {
        var start = _i,
            l;
        if (syntax !== 'less') return fail(tokens[_i]);
        if (l = checkClazz(_i) || checkShash(_i)) _i +=l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (l = checkArguments(_i)) _i += l;
        if (l = checkSC(_i)) _i += l;
        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);
        return _i - start;
    }
    function _getMixin1() {
        var startPos = pos,
            x = [];
        x.push(checkClazz(pos) ? getClazz() : getShash());
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkArguments(pos)) x.push(getArguments());
        if (checkSC(pos)) x = x.concat(getSC());
        if (checkBlock(pos)) x.push(getBlock());
        return (needInfo?
            [getInfo(startPos), CSSPNodeType.MixinType] :
            [CSSPNodeType.MixinType])
            .concat(x);
    }
    function checkNamespace(_i) {
        if (tokens[_i].type === TokenType.VerticalLine) return 1;
        return fail(tokens[_i]);
    }
    function getNamespace() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.NamespaceType] :
            [CSSPNodeType.NamespaceType];
    }
    function checkNth(_i) {
        return checkNth1(_i) || checkNth2(_i);
    }
    function checkNth1(_i) {
        var start = _i;
        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.DecimalNumber && tokens[_i].value !== 'n') break;
        }
        if (_i !== start) {
            tokens[start].nth_last = _i - 1;
            return _i - start;
        }
        return fail(tokens[_i]);
    }
    function getNth() {
        var startPos = pos;
        if (tokens[pos].nth_last) {
            var n = needInfo?
                [getInfo(startPos), CSSPNodeType.NthType, joinValues(pos, tokens[pos].nth_last)] :
                [CSSPNodeType.NthType, joinValues(pos, tokens[pos].nth_last)];
            pos = tokens[pos].nth_last + 1;
            return n;
        }
        return needInfo?
            [getInfo(startPos), CSSPNodeType.NthType, tokens[pos++].value] :
            [CSSPNodeType.NthType, tokens[pos++].value];
    }
    function checkNth2(_i) {
        if (tokens[_i].value === 'even' || tokens[_i].value === 'odd') return 1;
        return fail(tokens[_i]);
    }
    function checkNthf(_i) {
        var start = _i,
            l = 0;
        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]); l++;
        if (tokens[_i++].value !== 'nth' || tokens[_i++].value !== '-') return fail(tokens[_i - 1]); l += 2;
        if ('child' === tokens[_i].value) {
            l += 1;
        } else if ('last-child' === tokens[_i].value +
            tokens[_i + 1].value +
            tokens[_i + 2].value) {
            l += 3;
        } else if ('of-type' === tokens[_i].value +
            tokens[_i + 1].value +
            tokens[_i + 2].value) {
            l += 3;
        } else if ('last-of-type' === tokens[_i].value +
            tokens[_i + 1].value +
            tokens[_i + 2].value +
            tokens[_i + 3].value +
            tokens[_i + 4].value) {
            l += 5;
        } else return fail(tokens[_i]);
        tokens[start + 1].nthf_last = start + l - 1;
        return l;
    }
    function getNthf() {
        pos++;
        var s = joinValues(pos, tokens[pos].nthf_last);
        pos = tokens[pos].nthf_last + 1;
        return s;
    }
    function checkNthselector(_i) {
        var start = _i,
            l;
        if (l = checkNthf(_i)) _i += l;
        else return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.LeftParenthesis || !tokens[_i].right) return fail(tokens[_i]);
        l++;
        var rp = tokens[_i++].right;
        while (_i < rp) {
            if (l = checkSC(_i)) _i += l;
            else if (l = checkUnary(_i)) _i += l;
            else if (l = checkNth(_i)) _i += l;
            else return fail(tokens[_i]);
        }
        return rp - start + 1;
    }
    function getNthselector() {
        var nthf = needInfo?
                [getInfo(pos), CSSPNodeType.IdentType, getNthf()] :
                [CSSPNodeType.IdentType, getNthf()],
            ns = needInfo?
                [getInfo(pos), CSSPNodeType.NthselectorType, nthf] :
                [CSSPNodeType.NthselectorType, nthf];
        pos++;
        while (tokens[pos].type !== TokenType.RightParenthesis) {
            if (checkSC(pos)) ns = ns.concat(getSC());
            else if (checkUnary(pos)) ns.push(getUnary());
            else if (checkNth(pos)) ns.push(getNth());
        }
        pos++;
        return ns;
    }
    function checkNumber(_i) {
        if (_i < tokens.length && tokens[_i].number_l) return tokens[_i].number_l;
        if (_i < tokens.length && tokens[_i].type === TokenType.DecimalNumber &&
            (!tokens[_i + 1] ||
                (tokens[_i + 1] && tokens[_i + 1].type !== TokenType.FullStop))
            ) return (tokens[_i].number_l = 1, tokens[_i].number_l);
        if (_i < tokens.length &&
            tokens[_i].type === TokenType.DecimalNumber &&
            tokens[_i + 1] && tokens[_i + 1].type === TokenType.FullStop &&
            (!tokens[_i + 2] || (tokens[_i + 2].type !== TokenType.DecimalNumber))
            ) return (tokens[_i].number_l = 2, tokens[_i].number_l);
        if (_i < tokens.length &&
            tokens[_i].type === TokenType.FullStop &&
            tokens[_i + 1].type === TokenType.DecimalNumber
            ) return (tokens[_i].number_l = 2, tokens[_i].number_l);
        if (_i < tokens.length &&
            tokens[_i].type === TokenType.DecimalNumber &&
            tokens[_i + 1] && tokens[_i + 1].type === TokenType.FullStop &&
            tokens[_i + 2] && tokens[_i + 2].type === TokenType.DecimalNumber
            ) return (tokens[_i].number_l = 3, tokens[_i].number_l);
        return fail(tokens[_i]);
    }
    function getNumber() {
        var s = '',
            startPos = pos,
            l = tokens[pos].number_l;
        for (var i = 0; i < l; i++) {
            s += tokens[pos + i].value;
        }
        pos += l;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.NumberType, s] :
            [CSSPNodeType.NumberType, s];
    }
    function checkOperator(_i) {
        if (_i >= tokens.length) return fail(tokens[_i]);
        switch(tokens[_i].type) {
            case TokenType.Solidus:
            case TokenType.Comma:
            case TokenType.Colon:
            case TokenType.EqualsSign:
                return 1;
            case TokenType.LessThanSign:
            case TokenType.GreaterThanSign:
            case TokenType.Asterisk:
                if (['scss', 'less'].indexOf(syntax) > -1) return 1;
        }
        return fail(tokens[_i]);
    }
    function getOperator() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.OperatorType, tokens[pos++].value] :
            [CSSPNodeType.OperatorType, tokens[pos++].value];
    }
    function checkParentSelector(_i) {
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (tokens[_i].type !== TokenType.Ampersand) return fail(tokens[_i]);
        return 1;
    }
    function getParentSelector() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.ParentSelectorType, '&'] :
            [CSSPNodeType.ParentSelectorType, '&'];
    }
    function checkPercentage(_i) {
        var x = checkNumber(_i);
        if (!x || (x && _i + x >= tokens.length)) return fail(tokens[_i]);
        if (tokens[_i + x].type === TokenType.PercentSign) return x + 1;
        return fail(tokens[_i]);
    }
    function getPercentage() {
        var startPos = pos,
            n = getNumber();
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.PercentageType, n] :
            [CSSPNodeType.PercentageType, n];
    }
    function checkPlaceholder(_i) {
        var l;
        if (syntax !== 'scss') fail(tokens[_i]);
        if (_i >= tokens.length) return fail(tokens[_i]);
        if (tokens[_i].placeholder_l) return tokens[_i].placeholder_l;
        if (tokens[_i].type === TokenType.PercentSign) {
            if (l = checkIdent(_i + 1)) {
                tokens[_i].placeholder_l = l + 1;
                return l + 1;
            }
        }
        return fail(tokens[_i]);
    }
    function getPlaceholder() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.PlaceholderType, getIdent()] :
            [CSSPNodeType.PlaceholderType, getIdent()];
    }
    function checkProgid(_i) {
        var start = _i,
            l;
        if (l = checkSC(_i)) _i += l;
        if (joinValues2(_i, 6) === 'progid:DXImageTransform.Microsoft.') {
            _i += 6;
        } else return fail(tokens[_i - 1]);
        if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        if (tokens[_i].type === TokenType.LeftParenthesis) {
            tokens[start].progid_end = tokens[_i].right;
            _i = tokens[_i].right + 1;
        } else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function getProgid() {
        var progid_end = tokens[pos].progid_end;
        return (needInfo? [getInfo(pos), CSSPNodeType.ProgidType] : [CSSPNodeType.ProgidType])
            .concat(getSC())
            .concat([_getProgid(progid_end)])
            .concat(getSC());
    }
    function _getProgid(progid_end) {
        var startPos = pos,
            x = joinValues(pos, progid_end);
        pos = progid_end + 1;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.RawType, x] :
            [CSSPNodeType.RawType, x];
    }
    function checkProperty(_i) {
        var start = _i,
            l;
        if (l = checkVariable(_i)) _i += l;
        else if (l = checkIdent(_i)) _i += l;
        else return fail(tokens[_i]);
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function getProperty() {
        return (needInfo?
            [getInfo(pos), CSSPNodeType.PropertyType, checkVariable(pos) ? getVariable() : getIdent()] :
            [CSSPNodeType.PropertyType, checkVariable(pos) ? getVariable() : getIdent()])
            .concat(getSC());
    }
    function checkPseudo(_i) {
        return checkPseudoe(_i) ||
            checkPseudoc(_i);
    }
    function getPseudo() {
        if (checkPseudoe(pos)) return getPseudoe();
        if (checkPseudoc(pos)) return getPseudoc();
    }
    function checkPseudoe(_i) {
        var l;
        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);
        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);
        if (l = checkInterpolatedVariable(_i) || checkIdent(_i)) return l + 2;
        return fail(tokens[_i]);
    }
    function getPseudoe() {
        var startPos = pos;
        pos += 2;
        var x = checkInterpolatedVariable(pos) ? getInterpolatedVariable() : getIdent();
        return needInfo?
            [getInfo(startPos), CSSPNodeType.PseudoeType, x] :
            [CSSPNodeType.PseudoeType, x];
    }
    function checkPseudoc(_i) {
        var l;
        if (tokens[_i++].type !== TokenType.Colon) return fail(tokens[_i - 1]);
        if (l = checkInterpolatedVariable(_i) || checkFunktion(_i) || checkIdent(_i)) return l + 1;
        return fail(tokens[_i]);
    }
    function getPseudoc() {
        var startPos = pos;
        pos++;
        var x = checkInterpolatedVariable(pos) ? getInterpolatedVariable() : (checkFunktion(pos) ? getFunktion() : getIdent());
        return needInfo?
            [getInfo(startPos), CSSPNodeType.PseudocType, x] :
            [CSSPNodeType.PseudocType, x];
    }
    function checkRuleset(_i) {
        var start = _i,
            l;
        if (tokens[start].ruleset_l !== undefined) return tokens[start].ruleset_l;
        while (l = checkSelector(_i)) {
            _i += l;
        }
        if (l = checkBlock(_i)) _i += l;
        else return fail(tokens[_i]);
        tokens[start].ruleset_l = _i - start;
        return _i - start;
    }
    function getRuleset() {
        var ruleset = needInfo? [getInfo(pos), CSSPNodeType.RulesetType] : [CSSPNodeType.RulesetType];
        while (!checkBlock(pos)) {
            ruleset.push(getSelector());
        }
        ruleset.push(getBlock());
        return ruleset;
    }
    function checkS(_i) {
        if (tokens[_i].ws) return tokens[_i].ws_last - _i + 1;
        return fail(tokens[_i]);
    }
    function getS() {
        var startPos = pos,
            s = joinValues(pos, tokens[pos].ws_last);
        pos = tokens[pos].ws_last + 1;
        return needInfo? [getInfo(startPos), CSSPNodeType.SType, s] : [CSSPNodeType.SType, s];
    }
    function checkSC(_i) {
        var l,
            lsc = 0;
        while (_i < tokens.length) {
            if (!(l = checkS(_i)) &&
                !(l = checkCommentML(_i)) &&
                !(l = checkCommentSL(_i))) break;
            _i += l;
            lsc += l;
        }
        if (lsc) return lsc;
        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);
        return fail(tokens[_i]);
    }
    function getSC() {
        var sc = [];
        while (pos < tokens.length) {
            if (checkS(pos)) sc.push(getS());
            else if (checkCommentML(pos)) sc.push(getCommentML());
            else if (checkCommentSL(pos)) sc.push(getCommentSL());
            else break;
        }
        return sc;
    }
    function checkSelector(_i) {
        var start = _i,
            l;
        if (_i < tokens.length) {
            while (l = checkSimpleselector(_i) || checkDelim(_i)) {
                _i += l;
            }
            tokens[start].selector_end = _i - 1;
            return _i - start;
        }
    }
    function getSelector() {
        var selector = needInfo? [getInfo(pos), CSSPNodeType.SelectorType] : [CSSPNodeType.SelectorType],
            selector_end = tokens[pos].selector_end;
        while (pos <= selector_end) {
            selector.push(checkDelim(pos) ? getDelim() : getSimpleSelector());
        }
        return selector;
    }
    function checkShash(_i) {
        if (tokens[_i].type !== TokenType.NumberSign) return fail(tokens[_i]);
        var l = checkNmName(_i + 1);
        if (l) return l + 1;
        return fail(tokens[_i]);
    }
    function getShash() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.ShashType, getNmName()] :
            [CSSPNodeType.ShashType, getNmName()];
    }
    function checkSimpleselector(_i) {
        var start = _i,
            l;
        while (_i < tokens.length) {
            if (l = _checkSimpleSelector0(_i)) _i += l;
            else break;
        }
        if (_i - start) return _i - start;
        if (_i >= tokens.length) return fail(tokens[tokens.length - 1]);
        return fail(tokens[_i]);
    }
    function _checkSimpleSelector0(_i) {
        return checkParentSelector(_i) ||
            checkNthselector(_i) ||
            checkCombinator(_i) ||
            checkAttrib(_i) ||
            checkPseudo(_i) ||
            checkShash(_i) ||
            checkAny(_i) ||
            checkSC(_i) ||
            checkNamespace(_i);
    }
    function _checkSimpleSelector1(_i) {
        return checkParentSelector(_i) ||
            checkNthselector(_i) ||
            checkAttrib(_i) ||
            checkPseudo(_i) ||
            checkShash(_i) ||
            checkPlaceholder(_i) ||
            checkIdent(_i) ||
            checkClazz(_i);
    }
    function getSimpleSelector() {
        var ss = needInfo? [getInfo(pos), CSSPNodeType.SimpleselectorType] : [CSSPNodeType.SimpleselectorType],
            t;
        while (pos < tokens.length && _checkSimpleSelector0(pos)) {
            t = _getSimpleSelector0();
            if ((needInfo && typeof t[1] === 'string') || typeof t[0] === 'string') ss.push(t);
            else ss = ss.concat(t);
        }
        return ss;
    }
    function _getSimpleSelector0() {
        if (checkParentSelector(pos)) return getParentSelector();
        else if (checkNthselector(pos)) return getNthselector();
        else if (checkCombinator(pos)) return getCombinator();
        else if (checkAttrib(pos)) return getAttrib();
        else if (checkPseudo(pos)) return getPseudo();
        else if (checkShash(pos)) return getShash();
        else if (checkAny(pos)) return getAny();
        else if (checkSC(pos)) return getSC();
        else if (checkNamespace(pos)) return getNamespace();
    }
    function _getSimpleSelector1() {
        if (checkParentSelector(pos)) return getParentSelector();
        else if (checkNthselector(pos)) return getNthselector();
        else if (checkAttrib(pos)) return getAttrib();
        else if (checkPseudo(pos)) return getPseudo();
        else if (checkShash(pos)) return getShash();
        else if (checkPlaceholder(pos)) return getPlaceholder();
        else if (checkIdent(pos)) return getIdent();
        else if (checkClazz(pos)) return getClazz();
    }
    function checkString(_i) {
        if (_i < tokens.length &&
            (tokens[_i].type === TokenType.StringSQ || tokens[_i].type === TokenType.StringDQ)
            ) return 1;
        return fail(tokens[_i]);
    }
    function getString() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.StringType, tokens[pos++].value] :
            [CSSPNodeType.StringType, tokens[pos++].value];
    }
    function checkStylesheet(_i) {
        var start = _i,
            l;
        while (_i < tokens.length) {
            if (l = checkSC(_i)) _i += l;
            else {
                currentBlockLN = tokens[_i].ln;
                if (l = checkDeclaration(_i)) _i += l;
                else if (l = checkDecldelim(_i)) _i += l;
                else if (l = checkInclude(_i)) _i += l;
                else if (l = checkMixin(_i)) _i += l;
                else if (l = checkLoop(_i)) _i += l;
                else if (l = checkAtrule(_i)) _i += l;
                else if (l = checkRuleset(_i)) _i += l;
                else if (l = checkUnknown(_i)) _i += l;
                else throwError();
            }
        }
        return _i - start;
    }
    function getStylesheet() {
        var stylesheet = needInfo? [getInfo(pos), CSSPNodeType.StylesheetType] : [CSSPNodeType.StylesheetType];
        while (pos < tokens.length) {
            if (checkSC(pos)) stylesheet = stylesheet.concat(getSC());
            else {
                currentBlockLN = tokens[pos].ln;
                if (checkRuleset(pos)) stylesheet.push(getRuleset());
                else if (checkInclude(pos)) stylesheet.push(getInclude());
                else if (checkMixin(pos)) stylesheet.push(getMixin());
                else if (checkLoop(pos)) stylesheet.push(getLoop());
                else if (checkAtrule(pos)) stylesheet.push(getAtrule());
                else if (checkDeclaration(pos)) stylesheet.push(getDeclaration());
                else if (checkDecldelim(pos)) stylesheet.push(getDecldelim());
                else if (checkUnknown(pos)) stylesheet.push(getUnknown());
                else throwError();
            }
        }
        return stylesheet;
    }
    function checkTset(_i) {
        return checkVhash(_i) ||
            checkAny(_i) ||
            checkSC(_i) ||
            checkOperator(_i);
    }
    function getTset() {
        if (checkVhash(pos)) return getVhash();
        else if (checkAny(pos)) return getAny();
        else if (checkSC(pos)) return getSC();
        else if (checkOperator(pos)) return getOperator();
    }
    function checkTsets(_i) {
        var start = _i,
            l;
        while (l = checkTset(_i)) {
            _i += l;
        }
        return _i - start;
    }
    function getTsets() {
        var tsets = [],
            x;
        while (x = getTset()) {
            if ((needInfo && typeof x[1] === 'string') || typeof x[0] === 'string') tsets.push(x);
            else tsets = tsets.concat(x);
        }
        return tsets;
    }
    function checkUnary(_i) {
        if (_i < tokens.length &&
            (tokens[_i].type === TokenType.HyphenMinus ||
                tokens[_i].type === TokenType.PlusSign)
            ) return 1;
        return fail(tokens[_i]);
    }
    function getUnary() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.UnaryType, tokens[pos++].value] :
            [CSSPNodeType.UnaryType, tokens[pos++].value];
    }
    function checkUnknown(_i) {
        if (_i < tokens.length && tokens[_i].type === TokenType.CommentSL) return 1;
        return fail(tokens[_i]);
    }
    function getUnknown() {
        return needInfo?
            [getInfo(pos), CSSPNodeType.UnknownType, tokens[pos++].value] :
            [CSSPNodeType.UnknownType, tokens[pos++].value];
    }
    function checkUri(_i) {
        var start = _i;
        if (_i < tokens.length && tokens[_i++].value !== 'url') return fail(tokens[_i - 1]);
        if (!tokens[_i] || tokens[_i].type !== TokenType.LeftParenthesis) return fail(tokens[_i]);
        return tokens[_i].right - start + 1;
    }
    function getUri() {
        var startPos = pos,
            uriExcluding = {},
            uri,
            l,
            raw;
        pos += 2;
        uriExcluding[TokenType.Space] = 1;
        uriExcluding[TokenType.Tab] = 1;
        uriExcluding[TokenType.Newline] = 1;
        uriExcluding[TokenType.LeftParenthesis] = 1;
        uriExcluding[TokenType.RightParenthesis] = 1;
        if (checkUri1(pos)) {
            uri = (needInfo? [getInfo(startPos), CSSPNodeType.UriType] : [CSSPNodeType.UriType])
                .concat(getSC())
                .concat([getString()])
                .concat(getSC());
            pos++;
            return uri;
        } else {
            uri = (needInfo? [getInfo(startPos), CSSPNodeType.UriType] : [CSSPNodeType.UriType])
                    .concat(getSC()),
            l = checkExcluding(uriExcluding, pos),
            raw = needInfo?
                [getInfo(pos), CSSPNodeType.RawType, joinValues(pos, pos + l)] :
                [CSSPNodeType.RawType, joinValues(pos, pos + l)];
            uri.push(raw);
            pos += l + 1;
            uri = uri.concat(getSC());
            pos++;
            return uri;
        }
    }
    function checkUri1(_i) {
        var start = _i,
            l = checkSC(_i);
        if (l) _i += l;
        if (tokens[_i].type !== TokenType.StringDQ && tokens[_i].type !== TokenType.StringSQ) return fail(tokens[_i]);
        _i++;
        if (l = checkSC(_i)) _i += l;
        return _i - start;
    }
    function checkValue(_i) {
        var start = _i,
            l;
        while (_i < tokens.length) {
            if (l = _checkValue(_i)) _i += l;
            if (!l || checkBlock(_i - l)) break;
        }
        if (_i - start) return _i - start;
        return fail(tokens[_i]);
    }
    function _checkValue(_i) {
        return checkSC(_i) ||
            checkInterpolatedVariable(_i) ||
            checkVariable(_i) ||
            checkVhash(_i) ||
            checkBlock(_i) ||
            checkAny(_i) ||
            checkAtkeyword(_i) ||
            checkOperator(_i) ||
            checkImportant(_i) ||
            checkDefault(_i);
    }
    function getValue() {
        var ss = needInfo? [getInfo(pos), CSSPNodeType.ValueType] : [CSSPNodeType.ValueType],
            t, _pos;
        while (pos < tokens.length) {
            _pos = pos;
            if (!_checkValue(pos)) break;
            t = _getValue();
            if ((needInfo && typeof t[1] === 'string') || typeof t[0] === 'string') ss.push(t);
            else ss = ss.concat(t);
            if (checkBlock(_pos)) break;
        }
        return ss;
    }
    function _getValue() {
        if (checkSC(pos)) return getSC();
        else if (checkInterpolatedVariable(pos)) return getInterpolatedVariable();
        else if (checkVariable(pos)) return getVariable();
        else if (checkVhash(pos)) return getVhash();
        else if (checkBlock(pos)) return getBlock();
        else if (checkAny(pos)) return getAny();
        else if (checkAtkeyword(pos)) return getAtkeyword();
        else if (checkOperator(pos)) return getOperator();
        else if (checkImportant(pos)) return getImportant();
        else if (checkDefault(pos)) return getDefault();
    }
    function checkVariable(_i) {
        var l;
        if (l = _checkVariable0(_i) || _checkVariable1(_i)) return l;
        return fail(tokens[_i]);
    }
    function getVariable() {
        var startPos = pos,
            x;
        pos++;
        if (syntax === 'less' && _checkVariable1(pos)) x = getVariable();
        else x = getIdent();
        return needInfo?
            [getInfo(startPos), CSSPNodeType.VariableType, x] :
            [CSSPNodeType.VariableType, x];
    }
    function _checkVariable0(_i) {
        var l;
        if (syntax !== 'scss') return fail(tokens[_i]);
        if (_i >= tokens.length || tokens[_i].type !== TokenType.DollarSign) return fail(tokens[_i]);
        if (l = checkIdent(_i + 1)) return l + 1;
        return fail(tokens[_i]);
    }
    function _checkVariable1(_i) {
        var l;
        if (syntax !== 'less') return fail(tokens[_i]);
        if (_i >= tokens.length || tokens[_i].type !== TokenType.CommercialAt) return fail(tokens[_i]);
        if (tokens[_i - 1] &&
            tokens[_i - 1].type === TokenType.CommercialAt &&
            tokens[_i - 2] &&
            tokens[_i - 2].type === TokenType.CommercialAt) return fail(tokens[_i]);
        if (l = checkVariable(_i + 1) || checkIdent(_i + 1)) return l + 1;
        return fail(tokens[_i]);
    }
    function checkVariablesList(_i) {
        var d = 0,
            l;
        if (['scss', 'less'].indexOf(syntax) < 0) return fail(tokens[_i]);
        if (l = checkVariable(_i)) _i+= l;
        else return fail(tokens[_i]);
        while (tokens[_i] && tokens[_i].type === TokenType.FullStop) {
            d++;
            _i++;
        }
        if (d === 3) return l + d;
        else return fail(tokens[_i]);
    }
    function getVariablesList() {
        var startPos = pos;
        var x = needInfo?
            [getInfo(startPos), CSSPNodeType.VariablesListType, getVariable()] :
            [CSSPNodeType.VariablesListType, getVariable()];
        pos += 3;
        return x;
    }
    function checkVhash(_i) {
        if (_i >= tokens.length || tokens[_i].type !== TokenType.NumberSign) return fail(tokens[_i]);
        var l = checkNmName2(_i + 1);
        if (l) return l + 1;
        return fail(tokens[_i]);
    }
    function getVhash() {
        var startPos = pos;
        pos++;
        return needInfo?
            [getInfo(startPos), CSSPNodeType.VhashType, getNmName2()] :
            [CSSPNodeType.VhashType, getNmName2()];
    }
    function checkNmName(_i) {
        var start = _i;
        if (tokens[_i].type === TokenType.HyphenMinus ||
            tokens[_i].type === TokenType.LowLine ||
            tokens[_i].type === TokenType.Identifier ||
            tokens[_i].type === TokenType.DecimalNumber) _i++;
        else return fail(tokens[_i]);
        for (; _i < tokens.length; _i++) {
            if (tokens[_i].type !== TokenType.HyphenMinus &&
                tokens[_i].type !== TokenType.LowLine &&
                tokens[_i].type !== TokenType.Identifier &&
                tokens[_i].type !== TokenType.DecimalNumber) break;
        }
        tokens[start].nm_name_last = _i - 1;
        return _i - start;
    }
    function getNmName() {
        var s = joinValues(pos, tokens[pos].nm_name_last);
        pos = tokens[pos].nm_name_last + 1;
        return s;
    }
    function checkNmName2(_i) {
        if (tokens[_i].type === TokenType.Identifier) return 1;
        else if (tokens[_i].type !== TokenType.DecimalNumber) return fail(tokens[_i]);
        _i++;
        if (!tokens[_i] || tokens[_i].type !== TokenType.Identifier) return 1;
        return 2;
    }
    function getNmName2() {
        var s = tokens[pos].value;
        if (tokens[pos++].type === TokenType.DecimalNumber &&
            pos < tokens.length &&
            tokens[pos].type === TokenType.Identifier
            ) s += tokens[pos++].value;
        return s;
    }
    function checkExcluding(exclude, _i) {
        var start = _i;
        while(_i < tokens.length) {
            if (exclude[tokens[_i++].type]) break;
        }
        return _i - start - 2;
    }
    function joinValues(start, finish) {
        var s = '';
        for (var i = start; i < finish + 1; i++) {
            s += tokens[i].value;
        }
        return s;
    }
    function joinValues2(start, num) {
        if (start + num - 1 >= tokens.length) return;
        var s = '';
        for (var i = 0; i < num; i++) {
            s += tokens[start + i].value;
        }
        return s;
    }
    function markSC() {
        var ws = -1,
            sc = -1,
            t;
        for (var i = 0; i < tokens.length; i++) {
            t = tokens[i];
            switch (t.type) {
                case TokenType.Space:
                case TokenType.Tab:
                case TokenType.Newline:
                    t.ws = true;
                    t.sc = true;
                    if (ws === -1) ws = i;
                    if (sc === -1) sc = i;
                    break;
                case TokenType.CommentML:
                case TokenType.CommentSL:
                    if (ws !== -1) {
                        tokens[ws].ws_last = i - 1;
                        ws = -1;
                    }
                    t.sc = true;
                    break;
                default:
                    if (ws !== -1) {
                        tokens[ws].ws_last = i - 1;
                        ws = -1;
                    }
                    if (sc !== -1) {
                        tokens[sc].sc_last = i - 1;
                        sc = -1;
                    }
            }
        }
        if (ws !== -1) tokens[ws].ws_last = i - 1;
        if (sc !== -1) tokens[sc].sc_last = i - 1;
    }
    return function(_syntax, _tokens, rule, _needInfo) {
        return _getAST(_syntax, _tokens, rule, _needInfo);
    }
}());
    return function(options) {
        var css, rule, _needInfo, _syntax;
        if (!options) throw new Error('We need a string to parse');
        if (typeof options === 'string') css = options;
        else {
            css = options.css;
            rule = options.rule;
            _needInfo = options.needInfo;
            _syntax = options.syntax || 'css';
        }
        return getAST(_syntax, getTokens(css, _syntax), rule, _needInfo);
    }
}());
